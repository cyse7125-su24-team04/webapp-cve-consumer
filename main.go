package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/IBM/sarama"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
)

type CVERecord struct {
	// Define the structure based on the provided JSON schema
	CVEDataType    string `json:"CVE_data_type"`
	CVEDataFormat  string `json:"CVE_data_format"`
	CVEDataVersion string `json:"CVE_data_version"`
	CVEDataMeta    struct {
		ID                string `json:"cveId"`
		AssignerOrgID     string `json:"assignerOrgId"`
		AssignerShortName string `json:"assignerShortName"`
		DatePublished     string `json:"datePublished"`
		DateReserved      string `json:"dateReserved"`
		DateUpdated       string `json:"dateUpdated"`
		State             string `json:"state"`
	} `json:"cveMetadata"`
	Containers struct {
		CNA struct {
			ProviderMetadata struct {
				OrgID     string `json:"orgId"`
				ShortName string `json:"shortName"`
			} `json:"providerMetadata"`
			Title        string `json:"title"`
			Descriptions []struct {
				Lang  string `json:"lang"`
				Value string `json:"value"`
			} `json:"descriptions"`
			Affected []struct {
				Product string `json:"product"`
				Version string `json:"version"`
			} `json:"affected"`
		} `json:"cna"`
	} `json:"containers"`
}

var (
	db          *sql.DB
	kafkaClient sarama.Client
	topic       string
)

func init() {
	godotenv.Load()
	topic = os.Getenv("KAFKA_TOPIC")
}

func consumeFromKafka(brokerList []string, topic string, groupID string, db *sql.DB) error {
	config := sarama.NewConfig()
	config.Consumer.Group.Rebalance.Strategy = sarama.BalanceStrategyRoundRobin
	config.Version = sarama.V2_1_0_0 // ensure the version is compatible with your Kafka

	client, err := sarama.NewClient(brokerList, config)
	if err != nil {
		return fmt.Errorf("error creating kafka client: %v", err)
	}
	defer client.Close()

	consumerGroup, err := sarama.NewConsumerGroupFromClient(groupID, client)
	if err != nil {
		return fmt.Errorf("error creating consumer group: %v", err)
	}
	defer consumerGroup.Close()

	ctx := context.Background()
	for {
		if err := consumerGroup.Consume(ctx, []string{topic}, &consumerGroupHandler{db: db}); err != nil {
			log.Printf("Error from consumer: %v", err)
			return err
		}
	}
}

type consumerGroupHandler struct {
	db *sql.DB
}

func (h *consumerGroupHandler) Setup(_ sarama.ConsumerGroupSession) error {
	return nil
}

func (h *consumerGroupHandler) Cleanup(_ sarama.ConsumerGroupSession) error {
	return nil
}

func (h *consumerGroupHandler) ConsumeClaim(sess sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
	for message := range claim.Messages() {
		var cve CVERecord
		err := json.Unmarshal(message.Value, &cve)
		if err != nil {
			log.Printf("Failed to unmarshal CVE record: %v", err)
			continue
		}

		err = storeInDatabase(h.db, cve)
		if err != nil {
			log.Printf("Failed to store CVE record in database: %v", err)
		}
		sess.MarkMessage(message, "")
	}
	return nil
}

func storeInDatabase(db *sql.DB, cve CVERecord) error {
	cveJSON, err := json.Marshal(cve)
	if err != nil {
		return fmt.Errorf("failed to marshal CVE: %v", err)
	}

	insertQuery := `
    INSERT INTO cve.cves (cve_id, data)
    VALUES ($1, $2)
    ON CONFLICT (cve_id) DO UPDATE SET data = EXCLUDED.data;
    `
	if _, err := db.Exec(insertQuery, cve.CVEDataMeta.ID, cveJSON); err != nil {
		return fmt.Errorf("failed to insert CVE: %v", err)
	}
	return nil
}

func healthzHandler(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("ok"))
}

func readinessHandler(w http.ResponseWriter, r *http.Request) {
	// Check Kafka connection
	if err := kafkaClient.RefreshMetadata(); err != nil {
		http.Error(w, "kafka connection failed", http.StatusInternalServerError)
		return
	}

	// Check if Kafka topic exists
	topics, err := kafkaClient.Topics()
	if err != nil || !contains(topics, topic) {
		http.Error(w, "kafka topic check failed", http.StatusInternalServerError)
		return
	}

	// Check PostgreSQL connection
	if err := db.Ping(); err != nil {
		http.Error(w, "database connection failed", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Write([]byte("ready"))
}

func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

func main() {
	brokerList := []string{os.Getenv("KAFKA_BROKER")}
	var err error

	fmt.Println("Connecting to Kafka...")
	kafkaClient, err = sarama.NewClient(brokerList, nil)
	if err != nil {
		fmt.Printf("Error connecting to Kafka: %v\n", err)
		return
	}
	defer kafkaClient.Close()

	fmt.Println("Connecting to PostgreSQL database...")
	connStr := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable", os.Getenv("DB_HOST"), os.Getenv("DB_PORT"), os.Getenv("DB_USER"), os.Getenv("DB_PASSWORD"), os.Getenv("DB_NAME"))
	db, err = sql.Open("postgres", connStr)
	if err != nil {
		fmt.Printf("Error connecting to database: %v\n", err)
		return
	}
	defer db.Close()

	groupID := "cve-consumer-group" // Consistent group ID across all instances
	go func() {
		err = consumeFromKafka(brokerList, topic, groupID, db)
		if err != nil {
			log.Printf("Failed to consume from Kafka: %v", err)
		}
	}()

	http.HandleFunc("/healthz", healthzHandler)
	http.HandleFunc("/readiness", readinessHandler)
	log.Fatal(http.ListenAndServe(":8080", nil))
}
